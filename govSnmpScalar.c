/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "govSnmp.h"
#include <math.h>

int main(void)
{
  netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID, NETSNMP_DS_AGENT_ROLE, 1);

  init_agent("govSnmpAgt");
  init_govSnmp();
  init_snmp("govSnmpAgt");
  //initialize_table_govSnmpRecordsTable();

  send_govSnmpLessPages_trap();
  send_govSnmpLowInk_trap();
  send_govSnmpNotPrinting_trap();

  int ret_val=0;
  while(1) {
        ret_val = agent_check_and_process(1);
        if (-1 == ret_val) {
            continue;
        }
    }

 return 0;
}

/** Initializes the govSnmp module */
void
init_govSnmp(void)
{
    const oid       govSnmpNoPages_oid[] =
        { 1, 3, 6, 1, 4, 1, 8072, 100, 1, 1 };
    const oid       govSnmpIntensity_oid[] =
        { 1, 3, 6, 1, 4, 1, 8072, 100, 1, 2 };
    const oid       govSnmpStatus_oid[] =
        { 1, 3, 6, 1, 4, 1, 8072, 100, 1, 3 };

    DEBUGMSGTL(("govSnmp", "Initializing\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("govSnmpNoPages", handle_govSnmpNoPages,
                             govSnmpNoPages_oid,
                             OID_LENGTH(govSnmpNoPages_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("govSnmpIntensity", handle_govSnmpIntensity,
                             govSnmpIntensity_oid,
                             OID_LENGTH(govSnmpIntensity_oid),
                             HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration
                            ("govSnmpStatus", handle_govSnmpStatus,
                             govSnmpStatus_oid,
                             OID_LENGTH(govSnmpStatus_oid),
                             HANDLER_CAN_RWRITE));
	//initialize_table_govSnmpRecordsTable();
}

int
handle_govSnmpNoPages(netsnmp_mib_handler *handler,
                      netsnmp_handler_registration *reginfo,
                      netsnmp_agent_request_info *reqinfo,
                      netsnmp_request_info *requests)
{	
     int no_of_pages = 0, ret;
     FILE *fp;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
	fp=fopen("/home/govind/projects/printer.txt","r+");
	fscanf(fp,"%d", &no_of_pages);
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,&no_of_pages,sizeof(no_of_pages));
  	fclose(fp);	
	break;

    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }*/
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
        */ 
        //if ( /* XXX if malloc, or whatever, failed: */ ) {
           // netsnmp_set_request_error(reqinfo, requests,
             //                         SNMP_ERR_RESOURCEUNAVAILABLE);
         //}
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
	fp=fopen("/home/govind/projects/printer.txt","r+");
	int i; 	
	//for(i = 0 ; requests->requestvb->val.string[i] = '\0'; i++)
		no_of_pages = strtol(requests->requestvb->val.string, NULL, 10);

	fprintf(fp,"%d",no_of_pages);
	if ( fp == 0 ) {
            netsnmp_set_request_error(reqinfo, requests,-999);
        }
	fclose(fp);
	break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        
         //if ( /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
          //  netsnmp_set_request_error(reqinfo, requests,
          //                            SNMP_ERR_COMMITFAILED);
        //}
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        //if ( /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
          //  netsnmp_set_request_error(reqinfo, requests,
            //                          SNMP_ERR_UNDOFAILED);
        //}
        break;



    default:
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_govSnmpNoPages\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_govSnmpIntensity(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests)
{
    int intensity,ret,pos;
    char s[100];
    FILE *fp;
    switch (reqinfo->mode) {

    case MODE_GET:
	fp=fopen("/home/govind/projects/printer.txt","r+");
	fgets(s,100,fp);
	pos = strlen(s);       	
	fseek(fp,pos,SEEK_SET);
	fscanf(fp,"%d",&intensity);
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,&intensity ,sizeof(intensity));
	fclose(fp);
        break;
 
    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }*/
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        //if ( /* XXX if malloc, or whatever, failed: */ ) {
         //   netsnmp_set_request_error(reqinfo, requests,
         //                             SNMP_ERR_RESOURCEUNAVAILABLE);
        //}
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;
    case MODE_SET_ACTION:
	fp=fopen("/home/govind/projects/printer.txt","r+");
	fgets(s,100,fp);	
	pos = strlen(s);       	
	fseek(fp,pos,SEEK_SET);
	intensity = *(requests->requestvb->val.string);
	fprintf (fp,"%d",intensity);
	if (intensity < 0 || intensity > 10) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,-999);
        }
	fclose(fp);
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        
        //if ( /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
          //  netsnmp_set_request_error(reqinfo, requests,
            //                          SNMP_ERR_COMMITFAILED);
        //}
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        //if ( /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            //netsnmp_set_request_error(reqinfo, requests,
          //                            SNMP_ERR_UNDOFAILED);
        //}
        break;

 
   default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_govSnmpIntensity\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_govSnmpStatus(netsnmp_mib_handler *handler,
                     netsnmp_handler_registration *reginfo,
                     netsnmp_agent_request_info *reqinfo,
                     netsnmp_request_info *requests)
{
    int pos, status,ret;
    char s[100];	
    FILE *fp;
    switch (reqinfo->mode) {

    case MODE_GET:
	fp=fopen("/home/govind/projects/printer.txt","r+");
	fgets(s,100,fp);       	
	pos = strlen(s);       	
	fseek(fp,pos+2,SEEK_SET);
	fscanf(fp,"%d",&status);        
	snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,&status,sizeof(status));
	fclose(fp);	
	break;

    case MODE_SET_RESERVE1:
        /*
         * or you could use netsnmp_check_vb_type_and_size instead 
         */
        //ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        //if (ret != SNMP_ERR_NOERROR) {
        //    netsnmp_set_request_error(reqinfo, requests, ret);
        //}
        break;

    case MODE_SET_RESERVE2:
        /*
         * XXX malloc "undo" storage buffer 
         */
        //if ( /* XXX if malloc, or whatever, failed: */ ) {
        //     netsnmp_set_request_error(reqinfo, requests,
        //                              SNMP_ERR_RESOURCEUNAVAILABLE);
        // }
        break;

    case MODE_SET_FREE:
        /*
         * XXX: free resources allocated in RESERVE1 and/or
         * RESERVE2.  Something failed somewhere, and the states
         * below won't be called. 
         */
        break;

    case MODE_SET_ACTION:
	fp=fopen("/home/govind/projects/printer.txt","r+");
	fgets(s,100,fp);       	
	pos = strlen(s);       	       	
	fseek(fp,pos+2,SEEK_SET);
	status = *(requests->requestvb->val.string);
	fprintf(fp,"%d",status);	
	if (status < 0 || status > 1) {
            /*
             * try _really_really_ hard to never get to this point 
             */
            netsnmp_set_request_error(reqinfo, requests,
                                      -999);
        }
	fclose(fp);
        break;

    case MODE_SET_COMMIT:
        /*
         * XXX: delete temporary storage 
         */
        
        //if ( /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
          //  netsnmp_set_request_error(reqinfo, requests,
            //                          SNMP_ERR_COMMITFAILED);
        //}
        break;

    case MODE_SET_UNDO:
        /*
         * XXX: UNDO and return to previous value for the object 
         */
        //if ( /* XXX: error? */ ) {
            /*
             * try _really_really_ hard to never get to this point 
             */
          //  netsnmp_set_request_error(reqinfo, requests,
            //                          SNMP_ERR_UNDOFAILED);
        //}
        break;


    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_govSnmpStatus\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}	
